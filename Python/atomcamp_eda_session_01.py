# -*- coding: utf-8 -*-
"""atomcamp EDA Session-01

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14GL8P97vDAH1difviEB031FFGJJ9Hd_Q

# **NUMPY**
"""

a = [4, 9, 8]
sum = 0
for i in a:
  sum += i

mean = sum / len(a)
print(mean)

"""Numpy

it is used to so complex mathematical operations
"""

import numpy as np

a = np.array([4,6,9])

a.mean()

a.max()

a.min()

"""1D array creation function

np.arange()

creates arrays with regularly incrementing values.
"""

a = np.arange(1, 11)

b = np.arange(1, 5)

b

a

b[0:2]

a[1:3] = 10, 14

a[-1]

a[1::2]

a[0:: 1]

a

a[0: 10 :3]

# array types
a.dtype

# change datatype of a
a = a.astype(np.float32)

a.dtype

a2 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9 , 10], dtype = float)

a2

a3 = np.array([1,2,3.0,5], dtype = int)
a4 = np.array([1,2,3.0,5])

a3.dtype

a3.dtype

a

np.arange(2, 10)

np.arange(2, 10, .5)

"""numpy.linspace()

will create arrays with a specified number of elements, and spaced equally between the specified beginning and end values.
"""

ap = np.linspace(1, 4., 6, dtype = int)
ap

"""activity"""

a1 = np. array([1, 2, 3, 4.5, 5, 6, 7, 8.9])

a2 = np. array([1, 2, 3, 4.5, 5, 6, 7, 8.9], dtype = int)

a3 = np. array([1, 2, 3, 4.5, 5, 6, 7, 8.9], dtype = float)

print(a1.dtype)
print(a2.dtype)
print(a3.dtype)

"""2d- arrays

The 2D array creation functions e.g. numpy.eye, numpy.diag, and numpy.vander define properties of special matrices represented as 2D arrays.

np.eye(n, m)

defines a 2D identity matrix. The elements where i=j (row index and column index are equal) are 1 and the rest are 0
"""

np.eye(3)

np.eye(3, 6)

"""numpy.diag

can define either a square 2D array with given values along the diagonal or if given a 2D array returns a 1D array that is only the diagonal elements. The two array creation functions can be helpful while doing linear algebra
"""

np.diag([1, 2, 3])

np.diag([1,2,3], 1)

np.diag([[1,2],
        [3, 4]])

"""vander(x, n)

defines a Vandermonde matrix as a 2D NumPy array. Each column of the Vandermonde matrix is a decreasing power of the input 1D array or list or tuple, x where the highest polynomial order is n-1. This array creation routine is helpful in generating linear least squares models
"""





import numpy as np
a = np.array(['hello', 'world', 5])
print(a, "\n", a.dtype)

# <U21 represents a Unicode string with a maximum length of 21 characters.
# It is a data type in NumPy that indicates the array stores strings
# encoded using Unicode, allowing for the use of characters from different languages.
# The 21 specifies the maximum number of characters allowed in a single element of the array.

A = np.array([[1,2,3],
             [4, 5, 6]])

A.shape # gives rows and columns numbers

A.ndim # check the dimension of array A

A.size # 2 rows 3 columns 2*3 = 6 elements





"""general ndarray creation functions

The ndarray creation functions e.g. numpy.ones, numpy.zeros, and random define arrays based upon the desired shape. The ndarray creation functions can create arrays with any dimension by specifying how many dimensions and length along that dimension in a tuple or list.

numpy.zeros will create an array filled with 0 values with the specified shape. The default dtype is float64
"""

import numpy as np
np.zeros((2, 3))
np.zeros((2, 3, 2))

"""numpy.ones will create an array filled with 1 values. It is identical to zeros in all other respects"""

B = np.array([
    [
        [1, 2, 6],
        [3, 4, 7]
    ],
    [
        [5, 6, 7],
        [7, 8, 9]
    ]
])

B.shape #  no. of matices inside the B, no. of rows, number of columns

B.ndim

B.size

# Square matrix
A = np.array([
#.   0. 1. 2
    [1, 2, 3], # 0
    [4, 5, 6], # 1
    [7, 8, 9]  # 2
])

A[1] # extracts the rows

A[0][1] # extracts the row and the columns value

A[1][1]

A[2][1]

# can also do:
 #[row, col]

A[1,0]

A[2, 1]

# accessing rows from -2, where 2 is not included
A[0:2]

# [row start: end, col start:end]
A[:, :2]

A[0:2, 1:3]

A[0:2, 1:]

A[0:2, 1:3:2] # giving alternate columns

A[:, 0:2]



"""Arrays are mutable"""

# can update, delete, etc

A[1] = np.array([10, 10, 7])

A

A[2] = 9

A

A.var()

# Square matrix
A = np.array([
#.   0. 1. 2
    [1, 2, 3], # 0
    [4, 5, 6], # 1
    [7, 8, 9]  # 2
])

A.sum()

A.mean()

# you want to have a row wise or column wise submission

# col wise sum
A.sum(axis = 0)
# 1+4+7
# 4 +5 6
# 7 8 + 9

# row wise submission
A.sum(axis = 1)

#mean across col
A.mean(axis=0)

# mean across row
A.mean(axis = 1)

a = np.arange(4)

a

a + b

a * b

np.transpose(A)

c = [
    [1,2,3],
    [4,5,6]
]

np.transpose(c)

np.random.random(size = 2)

np.random.normal(size = 2)

np.random.rand(2, 4)
# rand(row, col)

np.random.randint(100, size = (1,8))
# randint(value range, size = (row, col))

np.random.randint(100, size = (5,3))
# randint(value range, size = (row, col))
# randint will always start from 0 and will go on till the end value in the range

np.linspace(1,100, 10, dtype = int)
# linspace(start, end, number of values)

np.linspace(1,100, 10)

# to remove the 100 in the range as by default the end value is also included
np.linspace(1,100, 10, False, dtype = int)
# linspace(start, end, number of values)

# Types of Sampling in Statistics

# Sampling is a process used in statistical analysis to select a subset of individuals from a larger population to estimate characteristics of the whole population.
# There are several types of sampling methods used depending on the research question and the characteristics of the population being studied.

# 1. Probability Sampling
#    - In probability sampling, each member of the population has a known chance of being selected.
#    - It allows for the estimation of sampling error and the generalizability of findings to the larger population.

#    a. Simple Random Sampling:
#       - Each member of the population has an equal chance of being selected.
#       - It is the most basic type of probability sampling and provides a representative sample if the population is homogeneous.


#    b. Stratified Random Sampling:
#       - The population is divided into strata or subgroups based on relevant characteristics.
#       - A random sample is then selected from each stratum, ensuring representation from different segments of the population.


#    c. Cluster Sampling:
#       - The population is divided into clusters, often geographical or organizational.
#       - A random sample of clusters is selected, and then all or a subset of individuals within the selected clusters is included in the sample.


#    d. Systematic Sampling:
#       - Individuals are selected from the population at a predetermined interval.
#       - For example, every 10th person on a list could be selected.
#       - It can be efficient but may introduce bias if there is a pattern in the population that aligns with the sampling interval.


# 2. Non-Probability Sampling
#    - In non-probability sampling, not every member of the population has a known chance of being selected.
#    - It is often used when it is difficult or impossible to obtain a probability sample.
#    - However, it can introduce bias and limit the generalizability of findings.

#    a. Convenience Sampling:
#       - Individuals are selected based on their availability or ease of access.
#       - For example, using students in a classroom as a sample for a study.


#    b. Quota Sampling:
#       - The sample is selected to reflect the proportions of certain characteristics in the population.
#       - For example, ensuring that the sample has an equal number of males and females.


#    c. Purposive Sampling:
#       - Individuals are selected based on their relevance to the research question.
#       - For example, selecting individuals with specific expertise or experience for an interview.


#    d. Snowball Sampling:
#       - Participants are asked to refer other individuals who might be suitable for the study.
#       - It is often used for hard-to-reach populations where members are connected through networks.

# Choosing the Right Sampling Method
# - The choice of sampling method depends on several factors, including the research question, the characteristics of the population, the available resources, and the desired level of accuracy.
# - It's important to consider the potential for bias and the generalizability of findings when selecting a sampling method.

